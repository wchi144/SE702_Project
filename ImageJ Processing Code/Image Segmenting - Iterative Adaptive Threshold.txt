//bit depth = 16 or 8
var depth = bitDepth();

//maxVal
var maxVal = pow(2, depth)-1;


Dialog.create("Image Segmentation using Modified Iterative Adaptive thresholding");

Dialog.addMessage("Performs modified iterative adaptive thresholding");
Dialog.show();

setBatchMode(true);

threshAdaptiveIter3class();

setBatchMode("exit and display");


// Performs iterative adaptive thresholding on 3 regions using 2 separate Thresholds for lower and upper bound of the material region. Assume a 8-bit grayscale image.
function threshAdaptiveIter3class() {
	// Question 3
	// Implement modified iterative adaptive thresholding


	//Histogram
	Histo = newArray(maxVal+1);
	for(x = 0; x < getWidth(); x++){
		for(y = 0; y < getHeight(); y++){
			Histo[getPixel(x,y)] = Histo[getPixel(x,y)] +1;
		}
	}					

	blackavoidance = 1;

	qpeak = 404;
	qmax = 404;

	peak = 0;
	for(d = blackavoidance; d < lengthOf(Histo); d++){
		if(Histo[d] > peak){
			peak = Histo[d];
			qpeak = d;
		}
	}


	//set fmax as the largest pixel intensity that has a count greater than zero.
	for(k = lengthOf(Histo)-1; k > 0; k--){
		if(Histo[k] > 0){
			qmax = k;
			k = 0;
		}	
	}
	
	zeroTheta1 = qpeak/2;
	zeroTheta2 = (qmax+qpeak)/2;

	print("ZeroThetas: " + zeroTheta1 + " " + zeroTheta2);

	theta1 = zeroTheta1;
	theta2 = zeroTheta2;
	prevTheta1 = 0;
	prevTheta2 = 0;

	iteration = 1;
	while(prevTheta1 != theta1 && prevTheta2 != theta2){
		prevTheta1 = theta1;
		prevTheta2 = theta2;

		//Compute Mean Grey Values for RegionP
		sumRp = 0;
		totalRp = 0;
		for(a = 1; a <= theta1; a++){
			sumRp += Histo[a]*a;
			totalRp += Histo[a];
		}
		meanRp = sumRp/totalRp;

		//Compute Mean Grey Values for RegionS
		sumRs = 0;
		totalRs = 0;
		for(b = theta1+1; b <= theta2; b++){
			sumRs += Histo[b]*b;
			totalRs += Histo[b];
		}
		meanRs = sumRs/totalRs;

		//Compute Mean Grey Values for RegionPC
		sumRpc = 0;
		totalRpc = 0;
		for(c = theta2+1; c <= qmax; c++){
			sumRpc += Histo[c]*c;
			totalRpc += Histo[c];
		}
		meanRpc = sumRpc/totalRpc;

		theta1 = round((meanRp + meanRs)/2);
		theta2 = round((meanRs + meanRpc)/2);

		if(iteration > 9){
			print("Max Iterations Reached");
			prevTheta1 = theta1;
			prevTheta2 = theta2;
		}
		iteration++;
	}

	print("Final Thetas: " + theta1 + " " + theta2);

	for(xi = 0; xi < getWidth(); xi++){
		for(yi = 0; yi < getHeight(); yi++){
			pix = getPixel(xi,yi);
			if(pix == 0){
				setPixel(xi,yi,maxVal);
			}
			else if(pix > theta2 && pix <= qmax){
				setPixel(xi,yi,(0.75*maxVal));
			}
			else if(pix > theta1 && pix <= theta2){
				setPixel(xi,yi,(0.5*maxVal));
			}
			else if(pix > 0 && pix <= theta1){
				setPixel(xi,yi,(0.25*maxVal));
			}
		}
	}
	updateDisplay();
	print("Done");

}

