//drag and drop 2 images on ImageJ

//bit depth = 16 or 8
var depth = bitDepth();

//maxVal
var maxVal = pow(2, depth)-1;

//print(depth);
print(maxVal);
print(depth);
imageNames = newArray(nImages);
for (i = 0; i < nImages; i++) {
	selectImage(i+1); // selectImage is 1-based index
	imageNames[i] = getTitle();
}
Dialog.create("Dialog Title");
Dialog.addChoice("Image 1", imageNames);
Dialog.addChoice("Image 2", imageNames);
Dialog.show();

img1Title = Dialog.getChoice();
img2Title = Dialog.getChoice();

setBatchMode(true);

selectWindow(img1Title);
width = getWidth();
height= getHeight();
print("Image 1");
print(width);print(height);

//implement your code

selectWindow(img2Title);
width = getWidth();
height= getHeight();
print("Image 2");
print(width);print(height);
//implement your code


print("Linear stretching, Begin, please wait...");
selectWindow(img1Title);
imageOne = imageToArray();
selectWindow(img2Title);
imageTwo = imageToArray();
LinStretch = LS(imageOne, imageTwo, getWidth(), getHeight());	
arrayToImage(LinStretch);
print("Done");
updateDisplay();

function imageToArray() {
	height = getHeight();
	width = getWidth();
	a = newArray(width * height);
	for (y = 0; y < height; y++) {
		for (x = 0; x < width; x++) {
			a[y * getWidth() + x] = getPixel(x, y);
		}
	}
	return a;
}

// writes an array to the active image
function arrayToImage(array) {
	width = getWidth();
	height = getHeight();
	for (y = 0; y < height; y++) {
		for (x = 0; x < width; x++) {
			setPixel(x, y, array[y * width + x]);
		}
	}
}


// performs Linear stretching as per Q2_a on array, returns output array and does not alter input array.
function LS(iarray, array, width, height) {	

	out = newArray(array.length);
	//implement your code here
	
	//Create Histogram
	cHisto = newArray(maxVal+1);
	for(i = 0; i < lengthOf(array); i++){
		cHisto[array[i]] = cHisto[array[i]] + 1;
	}

	//Create Histogram
	icHisto = newArray(maxVal+1);
	for(j = 0; j < lengthOf(iarray); j++){
		icHisto[iarray[j]] = icHisto[iarray[j]] + 1;
	}

	//Intialize varibles
	gmin = 1;
	gmax = maxVal;
	fmin = 55;
	fmax = 55555;

	blackavoidance = 1;

	//Find q1min
	for(a = 0; a < lengthOf(icHisto); a++){
		if(icHisto[a] > 0){
			gmin = a;
			print("value for gmin: " + a);
			a = lengthOf(icHisto);
		}
	}

	//Find q1peak
	ipeak = 0;
	for(b = blackavoidance; b < lengthOf(icHisto); b++){
		if(icHisto[b] > ipeak){
			ipeak = icHisto[b];
			gmax = b;
		}
	}
	print("value for gmax: " + gmax);

	//Find q2min
	for(c = 0; c < lengthOf(cHisto); c++){
		if(cHisto[c] > 0){
			fmin = c;
			print("value for fmin: " + c);
			c = lengthOf(cHisto);
		}
	}

	//Find q2peak
	peak = 0;
	for(d = blackavoidance; d < lengthOf(cHisto); d++){
		if(cHisto[d] > peak){
			peak = cHisto[d];
			fmax = d;
		}
	}
	print("value for fmax: " + fmax);

	//Create array of new stretched pixels
	for(l = 0; l < lengthOf(array); l++){
		out[l] = adjust(array[l], gmin, gmax, fmin, fmax);
	}
	return out;
}

//Calculate pixel g
function adjust(pixelv, gmin, gmax, fmin, fmax){

	b = gmin - fmin*((gmax - gmin)/(fmax-fmin));
	a = (gmax - gmin)/(fmax-fmin);
	s = (a*pixelv) + b;

	if(pixelv < gmin){
		g = gmin;
	}
	else if(pixelv <= gmax){
		g = s;
	}
	else if(pixelv > gmax){
		g = gmax;
	}

	return g;
}